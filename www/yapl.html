<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YAPL - Yet Another Programming Language</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
  <link href="https://fonts.googleapis.com/css2?family=Oldenburg&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/assets/style.css">
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Oldenburg", serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: #000;
      color: #fff;
      position: relative;
      z-index: 1;
    }

    dt-header {
      position: relative;
      z-index: 10;
      margin-bottom: 1em;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      z-index: 1;
      padding: 1em;
      padding-bottom: 4em; /* Space for fixed footer */
      overflow: hidden;
    }

    .header {
      background: #000;
      padding: 1rem;
      border-bottom: 2px solid #fff;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: "2Dumb";
      margin-bottom: 1rem;
    }

    .header h1 {
      font-size: 1.5rem;
      color: #fff;
      text-shadow: 2px 0 0 rgba(255, 0, 0, 0.5), -2px 0 0 rgba(0, 255, 255, 0.5);
    }

    .run-button {
      background: #000;
      color: #fff;
      border: 2px solid #fff;
      padding: 0.5rem 1.5rem;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      font-family: 'Courier New', monospace;
      transition: all 0.2s;
    }

    .run-button:hover {
      background: #fff;
      color: #000;
      text-shadow: none;
    }

    .run-button:active {
      background: #000;
      color: #fff;
    }

    .container {
      display: flex;
      flex: 1;
      overflow: hidden;
      gap: 1rem;
    }

    .pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      border: 2px solid #fff;
      background: #000;
    }

    .pane-header {
      background: #000;
      padding: 0.75rem 1rem;
      border-bottom: 2px solid #fff;
      font-weight: 500;
      color: #fff;
      font-size: 0.9rem;
      font-family: "2Dumb";
    }

    .editor-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #editor {
      flex: 1;
      width: 100%;
      padding: 1rem;
      background: #000;
      color: #fff;
      border: none;
      resize: none;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.5;
      tab-size: 2;
      outline: none;
    }

    #editor:focus {
      background: #000;
    }

    .js-container {
      flex: 1;
      overflow: auto;
      padding: 1rem;
      background: #000;
    }

    #javascript {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
      color: #fff;
    }

    .output-container {
      flex: 1;
      overflow: auto;
      padding: 1rem;
      background: #000;
    }

    #output {
      font-family: 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .error {
      color: #f00;
      text-shadow: 2px 0 0 rgba(255, 0, 0, 0.5);
    }

    .success {
      color: #0ff;
      text-shadow: -2px 0 0 rgba(0, 255, 255, 0.5);
    }

    .log-output {
      color: #fff;
      margin-bottom: 0.5rem;
    }

    .result-output {
      color: #fff;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 2px solid #fff;
      font-weight: 500;
      font-family: "2Dumb";
    }

    .example-link {
      color: #fff;
      text-decoration: none;
      font-size: 0.9rem;
      margin-left: 1rem;
      font-family: 'Courier New', monospace;
      border-bottom: 1px solid #fff;
    }

    .example-link:hover {
      text-shadow: 2px 0 0 rgba(255, 0, 0, 0.5), -2px 0 0 rgba(0, 255, 255, 0.5);
    }

    dt-footer {
      position: relative;
      z-index: 10;
    }
  </style>
  <script>
// YAPL Transpiler - Browser version
// Converts YAPL to JavaScript and executes with eval

class YAPLTranspiler {
  constructor() {
    this.functions = {};
    this.globals = {};
    this.params = {};
  }

  // Main entry point
  run(yamlContent) {
    // Use js-yaml from global scope (loaded via CDN)
    // The CDN version exposes it as 'jsyaml' (lowercase)
    const yamlLib = typeof jsyaml !== 'undefined' ? jsyaml : 
                    (typeof jsYAML !== 'undefined' ? jsYAML : null);
    
    if (!yamlLib) {
      throw new Error('js-yaml library not loaded. Make sure it is included via CDN.');
    }
    
    const ast = yamlLib.load(yamlContent);
    
    // Process AST
    const jsCode = this.transpile(ast);
    
    // Execute generated JavaScript
    return this.execute(jsCode);
  }

  // Transpile AST to JavaScript
  transpile(ast) {
    const parts = [];

    // Handle imports (for future expansion)
    if (ast.imports) {
      parts.push(`// Imports: ${ast.imports.join(', ')}`);
    }

    // Transpile globals
    if (ast.globals) {
      parts.push(...ast.globals.map(g => this.transpileGlobal(g)));
    }

    // Transpile functions
    if (ast.functions) {
      parts.push(...ast.functions.map(f => this.transpileFunction(f)));
    }

    // Transpile entry point
    if (ast.entry) {
      parts.push(this.transpileEntry(ast.entry));
    }

    return parts.join('\n\n');
  }

  // Transpile global variable
  transpileGlobal(global) {
    const name = global.name;
    const value = this.transpileExpr(global.value);
    this.globals[name] = true;
    return `let ${name} = ${value};`;
  }

  // Transpile function definition
  transpileFunction(func) {
    const name = func.name;
    const params = func.params || [];
    const body = func.body || [];
    
    this.functions[name] = true;

    // Track parameters so they're treated as identifiers in the function body
    const oldParams = { ...this.params };
    params.forEach(param => {
      this.params[param] = true;
    });

    // Handle body - could be single expression or list
    let bodyCode;
    if (Array.isArray(body)) {
      if (body.length === 0) {
        bodyCode = 'return null;';
      } else {
        const statements = body.map((stmt, i) => {
          const code = this.transpileExpr(stmt);
          // Last statement is return value
          return i === body.length - 1 ? `return ${code};` : `${code};`;
        });
        bodyCode = statements.join('\n  ');
      }
    } else {
      bodyCode = `return ${this.transpileExpr(body)};`;
    }

    // Restore previous params state
    this.params = oldParams;

    return `function ${name}(${params.join(', ')}) {\n  ${bodyCode}\n}`;
  }

  // Transpile entry point
  transpileEntry(entry) {
    if (!Array.isArray(entry)) {
      return `(${this.transpileExpr(entry)})();`;
    }

    const results = entry.map(expr => this.transpileExpr(expr));
    if (results.length === 0) {
      return `(() => { return null; })();`;
    }
    const statements = results.map((r, i) => 
      i === 0 ? `let _ = ${r};` : `_ = ${r};`
    );
    return `(() => {\n  ${statements.join('\n  ')}\n  return _;\n})();`;
  }

  // Transpile expression to JavaScript
  transpileExpr(expr) {
    // Handle null/undefined
    if (expr === null || expr === undefined) {
      return 'null';
    }

    // Handle arrays (expressions)
    if (Array.isArray(expr)) {
      return this.transpileArrayExpr(expr);
    }

    // Handle objects (special forms)
    if (typeof expr === 'object') {
      return this.transpileObjectExpr(expr);
    }

    // Handle variable/function reference (string) - check BEFORE primitives
    // because identifiers are also strings, but shouldn't be JSON.stringify'd
    if (typeof expr === 'string') {
      // Treat as identifier if it's registered as a function, global, or parameter
      // This prevents string literals like "YAPL" from being treated as identifiers
      if (this.functions[expr] || this.globals[expr] || this.params[expr]) {
        return this.transpileIdentifier(expr);
      }
      // Otherwise treat as string literal
      return JSON.stringify(expr);
    }

    // Handle primitives (numbers, booleans)
    if (this.isPrimitive(expr)) {
      return JSON.stringify(expr);
    }

    throw new Error(`Cannot transpile: ${JSON.stringify(expr)}`);
  }

  // Transpile identifier (variable, function, or JS global)
  transpileIdentifier(name) {
    // If it's a YAPL function or global, use it directly
    if (this.functions[name] || this.globals[name]) {
      return name;
    }
    
    // Otherwise, it's a JavaScript global - use it directly
    // JavaScript will resolve it at runtime
    return name;
  }

  // Transpile array expression
  transpileArrayExpr(expr) {
    if (expr.length === 0) {
      return '[]';
    }

    const [first, ...rest] = expr;

    // Check if first element is an operator
    if (typeof first === 'string' && this.isOperator(first)) {
      return this.transpileOperator(first, rest);
    }

    // Check if first element is property access operator
    if (first === '.') {
      return this.transpilePropertyAccess(rest);
    }

    // Function call - first element is function name
    const funcName = this.transpileIdentifier(first);
    const args = rest.map(arg => this.transpileExpr(arg));
    return `${funcName}(${args.join(', ')})`;
  }

  // Transpile object expression (special forms)
  transpileObjectExpr(expr) {
    // if statement
    if (expr.if) {
      const cond = this.transpileExpr(expr.if.cond);
      const thenExpr = this.transpileExpr(expr.if.then);
      const elseExpr = expr.if.else !== undefined 
        ? this.transpileExpr(expr.if.else)
        : 'null';
      return `(${cond} ? ${thenExpr} : ${elseExpr})`;
    }

    // while loop
    if (expr.while) {
      const cond = this.transpileExpr(expr.while.cond);
      const body = Array.isArray(expr.while.body)
        ? expr.while.body.map(s => this.transpileExpr(s)).join(';\n    ')
        : this.transpileExpr(expr.while.body);
      return `(() => {\n    while (${cond}) {\n      ${body};\n    }\n  })()`;
    }

    // let binding
    if (expr.let) {
      return this.transpileLet(expr.let);
    }

    // return statement
    if (expr.return !== undefined) {
      return this.transpileExpr(expr.return);
    }

    // Object literal
    const entries = Object.entries(expr).map(([k, v]) => {
      return `${k}: ${this.transpileExpr(v)}`;
    });
    return `{${entries.join(', ')}}`;
  }

  // Transpile let binding
  transpileLet(letExpr) {
    if (typeof letExpr === 'object' && letExpr.name) {
      // Single binding
      const name = letExpr.name;
      const value = this.transpileExpr(letExpr.value);
      return `(() => { let ${name} = ${value}; return ${name}; })()`;
    } else if (Array.isArray(letExpr)) {
      // Multiple bindings
      const bindings = letExpr.map(b => {
        const name = b.name;
        const value = this.transpileExpr(b.value);
        return `let ${name} = ${value};`;
      }).join('\n    ');
      return `(() => {\n    ${bindings}\n  })()`;
    }
    throw new Error(`Invalid let form: ${JSON.stringify(letExpr)}`);
  }

  // Transpile operator
  transpileOperator(op, args) {
    const jsArgs = args.map(arg => this.transpileExpr(arg));

    switch (op) {
      // Arithmetic
      case '+':
        return args.length === 1 ? `+${jsArgs[0]}` : `(${jsArgs.join(' + ')})`;
      case '-':
        return args.length === 1 ? `-${jsArgs[0]}` : `(${jsArgs.join(' - ')})`;
      case '*':
        return `(${jsArgs.join(' * ')})`;
      case '/':
        return `(${jsArgs.join(' / ')})`;
      case '%':
        return `(${jsArgs[0]} % ${jsArgs[1]})`;
      case '**':
        return `(${jsArgs[0]} ** ${jsArgs[1]})`;

      // Comparison
      case '==':
        return `(${jsArgs[0]} === ${jsArgs[1]})`;
      case '!=':
        return `(${jsArgs[0]} !== ${jsArgs[1]})`;
      case '<':
        return `(${jsArgs[0]} < ${jsArgs[1]})`;
      case '>':
        return `(${jsArgs[0]} > ${jsArgs[1]})`;
      case '<=':
        return `(${jsArgs[0]} <= ${jsArgs[1]})`;
      case '>=':
        return `(${jsArgs[0]} >= ${jsArgs[1]})`;

      // Logical
      case '&&':
        return `(${jsArgs.join(' && ')})`;
      case '||':
        return `(${jsArgs.join(' || ')})`;
      case '!':
        return `(!${jsArgs[0]})`;

      // Type checking
      case 'typeof':
        return `(typeof ${jsArgs[0]})`;
      case 'instanceof':
        return `(${jsArgs[0]} instanceof ${jsArgs[1]})`;

      default:
        throw new Error(`Unknown operator: ${op}`);
    }
  }

  // Transpile property access
  transpilePropertyAccess(args) {
    if (args.length < 2) {
      throw new Error('Property access requires at least object and property');
    }

    const obj = this.transpileExpr(args[0]);
    const prop = args[1];
    
    // If property is a string, use dot notation or bracket notation
    if (typeof prop === 'string' && /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(prop)) {
      // Valid identifier, use dot notation
      if (args.length === 2) {
        return `${obj}.${prop}`;
      } else {
        // Method call
        const methodArgs = args.slice(2).map(arg => this.transpileExpr(arg));
        return `${obj}.${prop}(${methodArgs.join(', ')})`;
      }
    } else {
      // Use bracket notation
      const propExpr = this.transpileExpr(prop);
      if (args.length === 2) {
        return `${obj}[${propExpr}]`;
      } else {
        const methodArgs = args.slice(2).map(arg => this.transpileExpr(arg));
        return `${obj}[${propExpr}](${methodArgs.join(', ')})`;
      }
    }
  }

  // Check if string is an operator
  isOperator(str) {
    const operators = ['+', '-', '*', '/', '%', '**',
                      '==', '!=', '<', '>', '<=', '>=',
                      '&&', '||', '!',
                      'typeof', 'instanceof', '.'];
    return operators.includes(str);
  }

  // Check if value is primitive
  isPrimitive(value) {
    return typeof value === 'number' ||
           typeof value === 'string' ||
           typeof value === 'boolean';
  }

  // Execute generated JavaScript with eval
  execute(jsCode) {
    try {
      return eval(jsCode);
    } catch (error) {
      console.error('Generated JavaScript:', jsCode);
      throw error;
    }
  }
}
window.YAPLTranspiler = YAPLTranspiler;
</script>
</head>
<body>
  <dt-header></dt-header>
  <main>
    <div class="header">
      <h1>YAPL - Yet Another Programming Language</h1>
      <div>
        <a href="#" class="example-link" id="load-example">Load Example</a>
        <button class="run-button" onclick="runYAPL()">Run</button>
      </div>
    </div>
    
    <div class="container">
      <div class="pane">
        <div class="pane-header">Editor</div>
        <div class="editor-container">
          <textarea id="editor" spellcheck="false"></textarea>
        </div>
      </div>
      
      <div class="pane">
        <div class="pane-header">JavaScript</div>
        <div class="js-container">
          <div id="javascript">Transpiled JavaScript will appear here after running.</div>
        </div>
      </div>
      
      <div class="pane">
        <div class="pane-header">Output</div>
        <div class="output-container">
          <div id="output">Ready to run YAPL code. Click "Run" to execute.</div>
        </div>
      </div>
    </div>
  </main>
  <dt-footer><h-card></h-card><span>CC BY-NC-SA</span></dt-footer>
  <dt-background></dt-background>

  <script>
    // Default example code (loaded from example.yapl at build time)
    const defaultCode = `# YAPL Example - Demonstrates functions, globals, and JavaScript integration

functions:
  # Recursive Fibonacci function
  # Returns the nth Fibonacci number
  - name: fib
    params: [n]
    body:
      - if:
          cond: ['<', n, 2]  # Base case: fib(0) = 0, fib(1) = 1
          then: n
          else:
            # Recursive case: fib(n) = fib(n-1) + fib(n-2)
            ['+',
             [fib, ['-', n, 1]],
             [fib, ['-', n, 2]]]

  # Simple greeting function using JavaScript console.log
  - name: greet
    params: [name]
    body:
      - [console.log, ['+', "Hello, ", name, "!"]]

  # Recursive factorial function using block style YAML
  # Returns n! (n factorial)
  - name: factorial
    params: [n]
    body:
      - if:
          cond:
            - '<='
            - n
            - 1  # Base case: 0! = 1, 1! = 1
          then: 1
          else:
            # Recursive case: n! = n * (n-1)!
            - '*'
            - n
            - - factorial
              - - '-'
                - n
                - 1

# Global variables available throughout the program
globals:
  - name: pi
    value: 3.14159

# Entry point - code executed when program runs
entry:
  # Greet the user
  - [greet, "YAPL"]
  
  # Calculate Fibonacci number and store in a variable
  - let:
      name: fibResult
      value: [fib, 10]
  
  # Log the result
  - [console.log, fibResult]
  
  # Use global variable and JavaScript Math operations
  - [console.log, ['*', pi, 2]]  # Calculate 2Ï€
  
  # Call JavaScript built-in function
  - [Math.max, 1, 2, 3, 4, 5]
  
  # Calculate and display factorial using block style
  - - console.log
    - - '+'
      - "Factorial of 5: "
      - - factorial
        - 5`;

    // Load example code
    document.getElementById('load-example').addEventListener('click', (e) => {
      e.preventDefault();
      document.getElementById('editor').value = defaultCode;
    });

    // Override console.log to capture output
    const originalLog = console.log;
    const originalError = console.error;
    const logs = [];

    function captureConsole() {
      logs.length = 0;
      console.log = (...args) => {
        logs.push({ type: 'log', args });
        originalLog.apply(console, args);
      };
      console.error = (...args) => {
        logs.push({ type: 'error', args });
        originalError.apply(console, args);
      };
    }

    function restoreConsole() {
      console.log = originalLog;
      console.error = originalError;
    }

    function runYAPL() {
      const editor = document.getElementById('editor');
      const javascript = document.getElementById('javascript');
      const output = document.getElementById('output');
      const code = editor.value;

      if (!code.trim()) {
        output.innerHTML = '<span class="error">Please enter some YAPL code.</span>';
        javascript.textContent = '';
        return;
      }

      try {
        captureConsole();
        
        const transpiler = new YAPLTranspiler();
        
        // Get the transpiled JavaScript code
        // Parse YAML first to get AST, then transpile
        const ast = jsyaml.load(code);
        const jsCode = transpiler.transpile(ast);
        javascript.textContent = jsCode;
        
        // Execute the code
        const result = transpiler.run(code);

        restoreConsole();

        // Display logs (all results are now logged, so show them in order)
        let outputHTML = '';
        if (logs.length > 0) {
          outputHTML += '<div class="log-output">';
          logs.forEach(log => {
            const className = log.type === 'error' ? 'error' : '';
            const message = log.args.map(arg => {
              if (typeof arg === 'object') {
                return JSON.stringify(arg, null, 2);
              }
              return String(arg);
            }).join(' ');
            outputHTML += `<div class="${className}">${escapeHtml(message)}</div>`;
          });
          outputHTML += '</div>';
        }

        // Only show final result if it's different from the last logged value
        // (to avoid duplication since we're now logging all intermediate results)
        const lastLogValue = logs.length > 0 ? logs[logs.length - 1].args[0] : null;
        if (result !== undefined && result !== null && result !== lastLogValue) {
          const resultStr = typeof result === 'object' 
            ? JSON.stringify(result, null, 2)
            : String(result);
          outputHTML += `<div class="result-output">Final result: <span class="success">${escapeHtml(resultStr)}</span></div>`;
        } else if (logs.length === 0) {
          // Only show "no return value" if there were no logs at all
          outputHTML += '<div class="result-output">Result: <span class="success">(no return value)</span></div>';
        }

        output.innerHTML = outputHTML;
      } catch (error) {
        restoreConsole();
        output.innerHTML = `<div class="error">Error: ${escapeHtml(error.message)}</div>`;
        if (error.stack) {
          output.innerHTML += `<div class="error" style="margin-top: 0.5rem; font-size: 0.9rem;">${escapeHtml(error.stack)}</div>`;
        }
        // Show error in JavaScript pane too
        javascript.textContent = `// Error transpiling code:\n// ${error.message}`;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Load default example on page load
    document.getElementById('editor').value = defaultCode;
  </script>
</body>
</html>
